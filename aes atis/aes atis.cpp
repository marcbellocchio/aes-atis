#include "stdafx.h"


#include <cstdio>
#include <iostream>
#include "..\cryptopp\osrng.h"
using CryptoPP::AutoSeededRandomPool;

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <string>
using std::string;

#include <cstdlib>
using std::exit;

#include "..\cryptopp\cryptlib.h"
using CryptoPP::Exception;

#include "..\cryptopp\hex.h"
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;


#include "..\cryptopp\filters.h"
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::StreamTransformationFilter;

#include "..\cryptopp\des.h"
using CryptoPP::DES_EDE2;

#include "..\cryptopp\modes.h"
using CryptoPP::CBC_Mode;

#include "..\cryptopp\secblock.h"
using CryptoPP::SecByteBlock;
#include <iostream>
#include <string>
#include "..\cryptopp\modes.h"
#include "..\cryptopp\aes.h"
#include "..\cryptopp\filters.h"



int main(int argc, char* argv[]) {

	//HMODULE DLL = LoadLibrary(_T("cryptopp.dll"));
	//
	// Key and IV setup
	//AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-
	//bit). This key is secretly exchanged between two parties before communication
	//begins. DEFAULT_KEYLENGTH= 16 bytes

	// basic test to check library
	const byte message[] = { 'a', 'b', 'c' };
	const byte expectedDigest[] = { 0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D };
	byte digest[20];

	CryptoPP::SHA1 sha;
	sha.Update(message, 3);
	sha.Final(digest);

	if (memcmp(digest, expectedDigest, 20) != 0)
	{
		cerr << "SHA-1 hash failed.\n";
		abort();
	}
	cout << " SHA-1 hash succeeded.\n";

	//#Key 3b 34 47 a3 02 76 db d9 94 27 5e 85 b2 2c d8 8c
	const byte aesatisKEY[] = { 0x3b,0x34,0x47,0xa3,0x02,0x76,0xdb,0xd9,0x94,0x27,0x5e,0x85,0xb2,0x2c,0xd8,0x8c };
	const byte aesatisIV[] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
	byte aesatisCIPHER[256];
	// collected from a clear TS, second video packet
	const byte aesatisPLAIN[] = {0x5B, 0xF4, 0x71, 0xA8, 0x73, 0xA7, 0x72, 0x47, 0x8F, 0x4E, 0x27, 0xC0, 0x0D, 0x40, 0x3D, 0x86, 0x48, 0xB8, 0x67, 0xF5, 0x43, 0x94, 0x3B, 0xBC, 0x18, 0x3E, 0x78, 0xB6, 0x63, 0x85, 0xE5, 0x2F, 0x19, 0xC3, 0xE9, 0x21, 0x4E, 0xB1, 0x93, 0x59, 0xF2, 0x02, 0x11, 0x6D, 0x2E, 0xC3, 0x4F, 0x76, 0xAE, 0x9B, 0xA0, 0xB3, 0xBC, 0x3C, 0x70, 0x1B, 0x40, 0x49, 0x35, 0xEF, 0x3B, 0xF9, 0x44, 0x6A, 0x7E, 0x9D, 0xB6, 0x7D, 0x37, 0xE1, 0xA4, 0x1E, 0x8A, 0x5D, 0xB5, 0x99, 0x44, 0xB1, 0xBB, 0xB5, 0x9D, 0x2C, 0x00, 0x57, 0x6B, 0x48, 0xA9, 0x6C, 0x77, 0x0E, 0x93, 0x24, 0xF9, 0x51, 0x7E, 0xFD, 0xA3, 0xAB, 0xA1, 0xF5, 0x79, 0xBE, 0x27, 0x1A, 0x3A, 0xE4, 0x0E, 0x02, 0x04, 0x64, 0xEF, 0xC2, 0xE3, 0x2F, 0x56, 0xC1, 0xBC, 0xED, 0x91, 0xB1, 0x6E, 0x52, 0xDE, 0x7F, 0x6F, 0x81, 0x38, 0x74, 0x82, 0x90, 0xF0, 0xCD, 0x6E, 0xB9, 0xFC, 0x50, 0x00, 0xFF, 0x89, 0x82, 0xF4, 0x07, 0x38, 0xE0, 0x23, 0xBD, 0x3E, 0xEF, 0x1F, 0x34, 0xF5, 0x67, 0xCD, 0xED, 0x1C, 0x27, 0x2C, 0x88, 0xCD, 0xA8, 0x13, 0xB1, 0x6D, 0x27, 0x9F, 0x5C, 0xD5, 0xC2, 0x9B, 0x6C, 0x87, 0xE2, 0x0B, 0x52, 0x99, 0x7D, 0x33, 0x12, 0xD3, 0xF9, 0x19, 0xCB, 0xC0, 0xD6};

	// only first bytes to check
	const byte aesatisRefEncrypted[] = { 0x36, 0x68, 0x5D, 0x8C, 0x9A, 0xDA};

	CBC_Mode< CryptoPP::AES >::Encryption e;
	e.SetKeyWithIV(aesatisKEY, 16, aesatisIV);
	StreamTransformationFilter filter(e,NULL, CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme::NO_PADDING_IDSA);
	// push data for encryption
	filter.Put(aesatisPLAIN, 184);
	// do encryption
	filter.MessageEnd();
	// get data in internal buffer, size should be greater than payload of ts packet as i did a trick on a AES CBC
	size_t retsiz = filter.MaxRetrievable();
	if (retsiz > 184)
		retsiz = 184;
	filter.Get(aesatisCIPHER, retsiz);

	if (memcmp(aesatisCIPHER, aesatisRefEncrypted, 6) != 0)
	{
		cerr << "AES IDSA failed.\n";
		abort();
	}
	cout << " AES IDSA succeeded.\n";


	system("pause");

	return 0;
}